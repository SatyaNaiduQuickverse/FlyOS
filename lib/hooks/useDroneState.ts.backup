// lib/hooks/useDroneState.ts - REDIS INTEGRATED VERSION
import { useState, useEffect, useCallback, useRef } from 'react';

interface DroneData {
  id: string;
  model?: string;
  status?: string;
  latitude?: number;
  longitude?: number;
  altitude_msl?: number;
  altitude_relative?: number;
  armed?: boolean;
  flight_mode?: string;
  connected?: boolean;
  percentage?: number;
  voltage?: number;
  current?: number;
  gps_fix?: string;
  satellites?: number;
  hdop?: number;
  position_error?: number;
  roll?: number;
  pitch?: number;
  yaw?: number;
  velocity_x?: number;
  velocity_y?: number;
  velocity_z?: number;
  timestamp?: string;
  _meta?: {
    updatedAt?: number;
    source?: string;
  };
  [key: string]: any;
}

interface UseDroneStateOptions {
  droneId: string;
  token: string | null;
  initialFetch?: boolean;
  updateInterval?: number;
}

interface UseDroneStateReturn {
  drone: DroneData | null;
  isLoading: boolean;
  error: string | null;
  lastUpdate: Date | null;
  isConnected: boolean;
  latency: number | null;
  refreshDrone: () => Promise<void>;
  sendCommand: (commandType: string, parameters?: any) => Promise<any>;
}

export function useDroneState({
  droneId,
  token,
  initialFetch = true,
  updateInterval = 1000
}: UseDroneStateOptions): UseDroneStateReturn {
  const [drone, setDrone] = useState<DroneData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [lastUpdate, setLastUpdate] = useState<Date | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [latency, setLatency] = useState<number | null>(null);
  
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const isMountedRef = useRef(true);

  const refreshDrone = useCallback(async () => {
    if (!token || !droneId) {
      setError('Authentication or drone ID missing');
      setIsLoading(false);
      return;
    }

    try {
      const startTime = Date.now();
      
      const response = await fetch(`/api/drone-telemetry/${droneId}`, {
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        cache: 'no-store'
      });

      const endTime = Date.now();
      
      if (!isMountedRef.current) return;
      
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      
      setLatency(endTime - startTime);
      
      if (data && (data.latitude || data.connected !== undefined)) {
        setDrone(prevState => ({
          id: droneId,
          ...(prevState || {}),
          ...data,
          connected: data.connected !== false && !!data.latitude
        }));
        setError(null);
        setLastUpdate(new Date());
        setIsConnected(true);
      } else {
        setDrone(prevState => ({
          id: droneId,
          ...(prevState || {}),
          connected: false
        }));
        setIsConnected(false);
      }
      
    } catch (err: any) {
      console.error(`Error fetching drone ${droneId}:`, err);
      
      if (!isMountedRef.current) return;
      
      setError(`Connection error: ${err.message}`);
      setIsConnected(false);
      
      setDrone(prevState => prevState ? {
        ...prevState,
        connected: false
      } : {
        id: droneId,
        connected: false
      });
    } finally {
      if (isMountedRef.current) {
        setIsLoading(false);
      }
    }
  }, [droneId, token]);

  const sendCommand = useCallback(async (commandType: string, parameters: any = {}) => {
    if (!token || !droneId) {
      setError('Authentication required to send commands');
      return null;
    }

    try {
      console.log(`Sending ${commandType} command to drone ${droneId}:`, parameters);
      
      const response = await fetch(`/api/drones/${droneId}/command`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${token}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          commandType,
          parameters
        })
      });

      if (!response.ok) {
        throw new Error(`Command failed: HTTP ${response.status}`);
      }

      const result = await response.json();
      
      if (result.success) {
        console.log(`Command ${commandType} sent successfully to drone ${droneId}`);
        setTimeout(refreshDrone, 500);
        return result;
      } else {
        setError(result.message || 'Command failed');
        return null;
      }
    } catch (err: any) {
      console.error('Error sending command:', err);
      setError(`Command error: ${err.message}`);
      return null;
    }
  }, [droneId, token, refreshDrone]);

  useEffect(() => {
    if (!token || !droneId) return;

    isMountedRef.current = true;

    if (initialFetch) {
      refreshDrone();
    }

    intervalRef.current = setInterval(() => {
      if (isMountedRef.current) {
        refreshDrone();
      }
    }, updateInterval);

    return () => {
      isMountedRef.current = false;
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
        intervalRef.current = null;
      }
    };
  }, [droneId, token, initialFetch, updateInterval, refreshDrone]);

  useEffect(() => {
    return () => {
      isMountedRef.current = false;
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  return {
    drone,
    isLoading,
    error,
    lastUpdate,
    isConnected,
    latency,
    refreshDrone,
    sendCommand
  };
}
